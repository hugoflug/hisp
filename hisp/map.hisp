(import "core" ())

(defn new-node
  (& elems)
  (new "map" elems))

(defn insert
  (key value map)
  (let (node (unwrap map))
    (if (empty? node)
      (new-node (: key value) () ())
      (let 
        ((elem left right) node
        (key' _) elem)
          (ifs 
            (= key key') (new-node (: key value) left right)
            (< key key') (new-node elem (insert key value left) right)
            (> key key') (new-node elem left (insert key value right))
            (error "insert: Internal error"))))))

(defn lookup
  (key map)
  (let (node (unwrap map))
    (if (empty? node)
      nil
      (let 
        ((elem left right) node
        (key' value) elem)
          (ifs
            (= key key') value
            (< key key') (lookup key left)
            (> key key') (lookup key right)
            (error "lookup: Internal error"))))))

(defn mmap'
  (pairs)
  (if (empty? pairs)
    (new-node)
    (let
      ((key value) (head pairs))
        (insert key value (mmap' (tail pairs))))))
(defn mmap
  (& args)
  (mmap' (split-in-pairs args)))

(impl eq ((a "map") (b "map")) true)

(impl reduce 
  ((f nil) (start nil) (struct "map"))
  (if (empty? (unwrap struct)) 
    start
    (let ((elem left right) (unwrap struct))
      (case (: (empty? (unwrap left)) (empty? (unwrap right)))
        (: true true) (f start elem)
        (: false true) (f (reduce f start left) elem)
        (: true false) (f (reduce f start right) elem)
        (: false false)
          (let 
            (lred (reduce f start left)
             nred (f lred elem))
              (reduce f nred right))))))

(reduce (fn (a b) (cons b a)) () (mmap 4 7 8 9 5 1))

(defn length
  (coll)
  (reduce (fn (a b) (+ a 1)) 0 coll))

;(length (mmap 
;  5 2 
;  7 3 
;  9 8 
;  6 2))

;(length (mmap 1 2 3 4 5 6 7 8))