(import "core" ())


(defn lookup-impl
  (args impls)
  (if (empty? impls)
    (error "No matching impl found")
    (let
      (impl (head impls)
       impl-types (head impl)
       impl-fn (second impl))
      (if (= (map type args) impl-types)
        (apply impl-fn args)
        (lookup-impl args (tail impls))))))

(defn impls-name
  (name) ; todo: use current namespace
  (new-symbol
    nil 
    (str "_" (second (eval (' (symbol-name (~ name))))) "_impls")))

(defmacro defmethod
  (name)
  (let (impls-sym (impls-name name))
       (if (eval (' (read (~ impls-sym))))
         nil
         (' (do
           (def (~ impls-sym) (new-ref))
           (put-ref (~ impls-sym) ())
           (defn (~ name) (& args) (lookup-impl args (~ impls-sym))))))))
(assert-equal (expand-macro (defmethod foo)) 
  (' 
    (do 
      (def _foo_impls (new-ref))
      (put-ref _foo_impls ())
      (defn foo (& args) (lookup-impl args _foo_impls)))))

(defmacro impl 
  (name args body)
  (' 
    (put-ref (~ (impls-name name))
      (cons 
        (cons 
          (~ (cons (' :) (map second args))) 
          (: (fn (~ (map head args)) (~ body))))
        (take-ref (~ (impls-name name)))))))
(assert-equal (expand-macro (impl eq ((a "int") (b "int")) (= a b))) 
  (' (put-ref _eq_impls (cons (cons (: "int" "int") (: (fn (a b) (= a b)))) (take-ref _eq_impls)))))

(defmethod eq)
(impl eq ((a "int") (b "int")) (= a b))
(impl eq ((a "string") (b "string")) false)
(impl eq ((a "dict") (b "dict")) (= (head (unwrap a)) (head (unwrap b))))

(impl car ((a "int")) ())

;(def d (new "dict" (: 1 2)))
;(def d2 (new "dict" (: 4 3)))

;(eq 4 4)
;(eq 4 5)
;(eq "a" "a")
;(eq () 2)

;(new-ref ())
;(new-ref)

;(put-ref 42)
;(take-ref)

;_eq_impls

;(eq d d2)